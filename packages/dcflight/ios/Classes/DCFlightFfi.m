/*
 * Copyright (c) Dotcorr Studio. and affiliates.
 *
 * Licensed under the PolyForm Noncommercial License 1.0.0.
 * Commercial use requires a license from DotCorr.
 */

#import <Foundation/Foundation.h>
#import <string.h>
#import "DCFlightFfi.h"

// Helper macro to safely execute on main thread
// Avoids deadlock if already on main thread
#define SAFE_MAIN_THREAD_EXEC(block) \
    if ([NSThread isMainThread]) { \
        block(); \
    } else { \
        dispatch_sync(dispatch_get_main_queue(), block); \
    }

// Import Swift classes via generated header
// Swift classes marked with @objc public are exposed to Objective-C via {MODULE}-Swift.h
// The module name is 'dcflight' from the podspec
// 
// IMPORTANT: This header is generated by Xcode during build
// The header will be available once Swift files are compiled
// 
// For CocoaPods frameworks, when importing from within the same module, use quotes
// The header is generated in: ${BUILT_PRODUCTS_DIR}/dcflight.framework/Headers/dcflight-Swift.h
// Xcode automatically adds framework Headers to the search path
//
// If you see "file not found" errors:
// 1. Ensure all Swift files compile successfully (no Swift errors)
// 2. Clean build folder (Product ‚Üí Clean Build Folder)
// 3. Rebuild the project
// 4. The header will be generated after Swift compilation completes
#import "dcflight-Swift.h"

// Global event callback function pointer
static DCFlightEventCallback g_eventCallback = NULL;
// Queue for events that need to be processed on Dart isolate thread
static NSMutableArray<NSDictionary*>* g_eventQueue = nil;
static dispatch_queue_t g_eventQueueLock = NULL;

void dcflight_set_event_callback(DCFlightEventCallback callback) {
    g_eventCallback = callback;
    if (g_eventQueue == nil) {
        g_eventQueue = [[NSMutableArray alloc] init];
        g_eventQueueLock = dispatch_queue_create("com.dotcorr.dcflight.eventqueue", DISPATCH_QUEUE_SERIAL);
    }
}

DCFlightEventCallback dcflight_get_event_callback(void) {
    return g_eventCallback;
}

void dcflight_send_event(int32_t viewId, const char* eventType, const char* eventDataJson) {
    // Queue the event for Dart to poll - we can't call FFI callbacks from native threads
    @synchronized(g_eventQueue) {
        if (g_eventQueue == nil) {
            g_eventQueue = [[NSMutableArray alloc] init];
        }
        [g_eventQueue addObject:@{
            @"viewId": @(viewId),
            @"eventType": [NSString stringWithUTF8String:eventType ?: ""],
            @"eventDataJson": [NSString stringWithUTF8String:eventDataJson ?: ""]
        }];
    }
}

// Get queued events for Dart to process (polling mechanism)
// Returns JSON array of events, or NULL if no events
const char* dcflight_get_queued_events(void) {
    if (g_eventQueue == nil || g_eventQueue.count == 0) {
        return NULL;
    }
    
    NSArray<NSDictionary*>* eventsToProcess = nil;
    @synchronized(g_eventQueue) {
        if (g_eventQueue.count == 0) {
            return NULL;
        }
        eventsToProcess = [g_eventQueue copy];
        [g_eventQueue removeAllObjects];
    }
    
    NSError* error = nil;
    NSData* jsonData = [NSJSONSerialization dataWithJSONObject:eventsToProcess options:0 error:&error];
    if (error != nil) {
        NSLog(@"‚ùå DCFlightFfi: Failed to serialize queued events: %@", error);
        return NULL;
    }
    
    NSString* jsonString = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
    // Allocate memory that will be freed by Dart
    char* result = strdup([jsonString UTF8String]);
    return result;
}

void dcflight_process_event_queue(void) {
    // This function is deprecated - use dcflight_get_queued_events instead
    // Kept for backward compatibility but does nothing
}

// Helper function to send events to Dart via callback
void sendEventToDart(int32_t viewId, NSString* eventType, NSDictionary* eventData) {
    if (g_eventCallback == NULL) {
        return;
    }
    
    NSError* error = nil;
    NSData* jsonData = [NSJSONSerialization dataWithJSONObject:eventData options:0 error:&error];
    if (error != nil) {
        NSLog(@"‚ùå DCFlightFfi: Failed to serialize event data: %@", error);
        return;
    }
    
    NSString* eventDataJson = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
    if (eventDataJson == nil) {
        NSLog(@"‚ùå DCFlightFfi: Failed to convert event data to string");
        return;
    }
    
    g_eventCallback(viewId, [eventType UTF8String], [eventDataJson UTF8String]);
}

// Override the event sending in DCMauiEventMethodHandler to use FFI callback
// We'll need to modify DCMauiEventMethodHandler to check for FFI callback first

bool dcflight_initialize(void) {
    __block bool result = false;
    @try {
        SAFE_MAIN_THREAD_EXEC(^{
            result = [DCFlightNative.shared initialize];
        });
        NSLog(@"‚úÖ DCFlightFfi: dcflight_initialize returned %d", result);
    } @catch (NSException *exception) {
        NSLog(@"‚ùå DCFlightFfi: Exception in dcflight_initialize: %@", exception);
        result = false;
    }
    return result;
}

bool dcflight_create_view(int32_t viewId, const char* viewType, const char* propsJson) {
    if (viewType == NULL || propsJson == NULL) {
        return false;
    }
    
    NSString* viewTypeStr = [NSString stringWithUTF8String:viewType];
    NSString* propsJsonStr = [NSString stringWithUTF8String:propsJson];
    
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared createViewWithViewId:viewId viewType:viewTypeStr propsJson:propsJsonStr];
    });
    return result;
}

bool dcflight_update_view(int32_t viewId, const char* propsJson) {
    if (propsJson == NULL) {
        return false;
    }
    
    NSString* propsJsonStr = [NSString stringWithUTF8String:propsJson];
    
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared updateViewWithViewId:viewId propsJson:propsJsonStr];
    });
    return result;
}

bool dcflight_delete_view(int32_t viewId) {
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared deleteViewWithViewId:viewId];
    });
    return result;
}

bool dcflight_detach_view(int32_t viewId) {
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared detachViewWithChildId:viewId];
    });
    return result;
}

bool dcflight_attach_view(int32_t childId, int32_t parentId, int32_t index) {
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared attachViewWithChildId:childId parentId:parentId index:index];
    });
    return result;
}

bool dcflight_set_children(int32_t viewId, const int32_t* childrenIds, int32_t childrenCount) {
    if (childrenIds == NULL || childrenCount < 0) {
        return false;
    }
    
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        NSMutableArray<NSNumber*>* intArray = [NSMutableArray arrayWithCapacity:childrenCount];
        for (int32_t i = 0; i < childrenCount; i++) {
            [intArray addObject:@(childrenIds[i])];
        }
        // Convert NSArray<NSNumber*> to [Int] for Swift
        NSMutableArray* swiftIntArray = [NSMutableArray arrayWithCapacity:childrenCount];
        for (NSNumber* num in intArray) {
            [swiftIntArray addObject:num];
        }
        result = [DCFlightNative.shared setChildrenWithViewId:viewId childrenIds:swiftIntArray];
    });
    return result;
}

bool dcflight_add_event_listeners(int32_t viewId, const char* eventTypes) {
    if (eventTypes == NULL) {
        return false;
    }
    
    NSString* eventTypesStr = [NSString stringWithUTF8String:eventTypes];
    NSData* data = [eventTypesStr dataUsingEncoding:NSUTF8StringEncoding];
    NSError* error = nil;
    NSArray<NSString*>* eventTypesArray = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
    if (error != nil || ![eventTypesArray isKindOfClass:[NSArray class]]) {
        NSLog(@"‚ùå DCFlightFfi: Failed to parse event types JSON: %@", error);
        return false;
    }
    
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared addEventListenersWithViewId:viewId eventTypes:eventTypesArray];
    });
    return result;
}

bool dcflight_remove_event_listeners(int32_t viewId, const char* eventTypes) {
    if (eventTypes == NULL) {
        return false;
    }
    
    NSString* eventTypesStr = [NSString stringWithUTF8String:eventTypes];
    NSData* data = [eventTypesStr dataUsingEncoding:NSUTF8StringEncoding];
    NSError* error = nil;
    NSArray<NSString*>* eventTypesArray = [NSJSONSerialization JSONObjectWithData:data options:0 error:&error];
    if (error != nil || ![eventTypesArray isKindOfClass:[NSArray class]]) {
        NSLog(@"‚ùå DCFlightFfi: Failed to parse event types JSON: %@", error);
        return false;
    }
    
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared removeEventListenersWithViewId:viewId eventTypes:eventTypesArray];
    });
    return result;
}

bool dcflight_start_batch_update(void) {
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared startBatchUpdate];
    });
    return result;
}

bool dcflight_commit_batch_update(const char* operationsJson) {
    if (operationsJson == NULL) {
        return false;
    }
    
    NSString* operationsJsonStr = [NSString stringWithUTF8String:operationsJson];
    NSData* jsonData = [operationsJsonStr dataUsingEncoding:NSUTF8StringEncoding];
    
    NSError* error = nil;
    id operations = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&error];
    if (error != nil || ![operations isKindOfClass:[NSArray class]]) {
        NSLog(@"‚ùå DCFlightFfi: Failed to parse operations JSON: %@", error);
        return false;
    }
    
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared commitBatchUpdateWithUpdates:operations];
    });
    return result;
}

bool dcflight_cancel_batch_update(void) {
    __block bool result = false;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared cancelBatchUpdate];
    });
    return result;
}

bool dcflight_tunnel(const char* componentType, const char* method, const char* paramsJson, char* resultJson, int32_t resultSize) {
    if (componentType == NULL || method == NULL || paramsJson == NULL || resultJson == NULL || resultSize <= 0) {
        return false;
    }
    
    NSString* componentTypeStr = [NSString stringWithUTF8String:componentType];
    NSString* methodStr = [NSString stringWithUTF8String:method];
    NSString* paramsJsonStr = [NSString stringWithUTF8String:paramsJson];
    
    NSData* jsonData = [paramsJsonStr dataUsingEncoding:NSUTF8StringEncoding];
    NSError* error = nil;
    id params = [NSJSONSerialization JSONObjectWithData:jsonData options:0 error:&error];
    if (error != nil || ![params isKindOfClass:[NSDictionary class]]) {
        NSLog(@"‚ùå DCFlightFfi: Failed to parse params JSON: %@", error);
        return false;
    }
    
    __block id result = nil;
    SAFE_MAIN_THREAD_EXEC(^{
        result = [DCFlightNative.shared handleTunnelMethodWithComponentType:componentTypeStr method:methodStr params:(NSDictionary*)params];
    });
    
    if (result == nil) {
        strncpy(resultJson, "null", resultSize - 1);
        resultJson[resultSize - 1] = '\0';
        return true;
    }
    
    NSString* resultStr = nil;
    
    // NSJSONSerialization only allows NSArray or NSDictionary as top-level objects.
    // We must handle simple types (NSString, NSNumber) separately.
    if ([result isKindOfClass:[NSDictionary class]] || [result isKindOfClass:[NSArray class]]) {
        NSError* error = nil;
        NSData* resultData = [NSJSONSerialization dataWithJSONObject:result options:0 error:&error];
        if (error == nil) {
            resultStr = [[NSString alloc] initWithData:resultData encoding:NSUTF8StringEncoding];
        } else {
            NSLog(@"‚ùå DCFlightFfi: Failed to serialize complex result: %@", error);
        }
    } else if ([result isKindOfClass:[NSString class]]) {
        // Escape the string and wrap in quotes to make it a valid JSON string fragment
        // This is safe for FFI transmission
        resultStr = [NSString stringWithFormat:@"\"%@\"", result];
    } else if ([result isKindOfClass:[NSNumber class]]) {
        // Numbers are valid JSON as-is
        resultStr = [result stringValue];
    }
    
    if (resultStr == nil) {
        strncpy(resultJson, "null", resultSize - 1);
        resultJson[resultSize - 1] = '\0';
        return false;
    }
    
    const char* resultCStr = [resultStr UTF8String];
    size_t resultLen = strlen(resultCStr);
    if (resultLen >= (size_t)resultSize) {
        NSLog(@"‚ùå DCFlightFfi: Result buffer too small (%zu >= %d)", resultLen, resultSize);
        return false; 
    }
    
    strncpy(resultJson, resultCStr, resultSize - 1);
    resultJson[resultSize - 1] = '\0';
    return true;
}

// Global screen dimensions callback function pointer
static DCFlightScreenDimensionsCallback g_screenDimensionsCallback = NULL;
// Queue for screen dimension changes that need to be processed on Dart isolate thread
static NSMutableArray<NSString*>* g_screenDimensionsQueue = nil;

void dcflight_set_screen_dimensions_callback(DCFlightScreenDimensionsCallback callback) {
    g_screenDimensionsCallback = callback;
    if (g_screenDimensionsQueue == nil) {
        g_screenDimensionsQueue = [[NSMutableArray alloc] init];
    }
}

void dcflight_send_screen_dimensions_changed(const char* dimensionsJson) {
    // Queue the dimensions change for Dart to poll - we can't call FFI callbacks from native threads
    // EXACT SAME PATTERN AS EVENTS
    @synchronized(g_screenDimensionsQueue) {
        if (g_screenDimensionsQueue == nil) {
            g_screenDimensionsQueue = [[NSMutableArray alloc] init];
        }
        NSString* dimensionsStr = [NSString stringWithUTF8String:dimensionsJson ?: ""];
        [g_screenDimensionsQueue addObject:dimensionsStr];
    }
}

// Get queued screen dimensions for Dart to process (polling mechanism)
// Returns JSON string, or NULL if no changes
const char* dcflight_get_queued_screen_dimensions(void) {
    if (g_screenDimensionsQueue == nil || g_screenDimensionsQueue.count == 0) {
        return NULL;
    }
    
    NSString* latestDimensions = nil;
    @synchronized(g_screenDimensionsQueue) {
        if (g_screenDimensionsQueue.count == 0) {
            return NULL;
        }
        // Get the most recent dimensions change (ignore older ones)
        latestDimensions = [g_screenDimensionsQueue lastObject];
        [g_screenDimensionsQueue removeAllObjects];
    }
    
    // Allocate memory that will be freed by Dart
    char* result = strdup([latestDimensions UTF8String]);
    return result;
}

void dcflight_process_screen_dimensions_queue(void) {
    // This function is deprecated - use dcflight_get_queued_screen_dimensions instead
    // Kept for backward compatibility but does nothing
}

bool dcflight_get_screen_dimensions(char* resultJson, int32_t resultSize) {
    if (resultJson == NULL || resultSize <= 0) {
        return false;
    }
    
    __block NSDictionary* dimensions = nil;
    SAFE_MAIN_THREAD_EXEC(^{
        dimensions = [DCFScreenUtilities.shared getScreenDimensionsDict];
    });
    
    if (dimensions == nil) {
        return false;
    }
    
    NSError* error = nil;
    NSData* jsonData = [NSJSONSerialization dataWithJSONObject:dimensions options:0 error:&error];
    if (error != nil) {
        NSLog(@"‚ùå DCFlightFfi: Failed to serialize screen dimensions: %@", error);
        return false;
    }
    
    NSString* dimensionsStr = [[NSString alloc] initWithData:jsonData encoding:NSUTF8StringEncoding];
    if (dimensionsStr == nil) {
        return false;
    }
    
    const char* dimensionsCStr = [dimensionsStr UTF8String];
    size_t dimensionsLen = strlen(dimensionsCStr);
    if (dimensionsLen >= (size_t)resultSize) {
        return false; // Buffer too small
    }
    
    strncpy(resultJson, dimensionsCStr, resultSize - 1);
    resultJson[resultSize - 1] = '\0';
    return true;
}

static NSString* g_sessionToken = nil;
static NSString* const kSessionTokenKey = @"dcflight_session_token";

// Helper to get session token from UserDefaults (persists across hot restarts)
static NSString* _getSessionToken() {
    if (g_sessionToken != nil) {
        return g_sessionToken;
    }
    // Try to load from UserDefaults (persists across hot restarts)
    NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
    NSString* savedToken = [defaults stringForKey:kSessionTokenKey];
    if (savedToken != nil && savedToken.length > 0) {
        g_sessionToken = savedToken;
        return savedToken;
    }
    return nil;
}

// Helper to save session token to UserDefaults
static void _saveSessionToken(NSString* token) {
    g_sessionToken = token;
    NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
    if (token != nil && token.length > 0) {
        [defaults setObject:token forKey:kSessionTokenKey];
    } else {
        [defaults removeObjectForKey:kSessionTokenKey];
    }
    [defaults synchronize];
}

bool dcflight_get_session_token(char* resultJson, int32_t resultSize) {
    if (resultJson == NULL || resultSize <= 0) {
        NSLog(@"‚ùå dcflight_get_session_token: Invalid parameters");
        return false;
    }
    
    NSString* token = _getSessionToken();
    NSLog(@"üî• dcflight_get_session_token: Retrieved token from UserDefaults: %@", token ?: @"(nil)");
    
    // Always return true, but write empty string if no token (Dart will convert to null)
    if (token == nil || token.length == 0) {
        NSLog(@"üî• dcflight_get_session_token: No token found, returning empty string");
        resultJson[0] = '\0';
        return true; // Return true with empty string
    }
    
    const char* tokenCStr = [token UTF8String];
    size_t tokenLen = strlen(tokenCStr);
    
    if (tokenLen >= (size_t)resultSize) {
        NSLog(@"‚ùå dcflight_get_session_token: Token too long: %zu >= %d", tokenLen, resultSize);
        return false;
    }
    
    strncpy(resultJson, tokenCStr, resultSize - 1);
    resultJson[resultSize - 1] = '\0';
    NSLog(@"‚úÖ dcflight_get_session_token: Token copied to buffer: %s", resultJson);
    return true;
}

bool dcflight_create_session_token(char* resultJson, int32_t resultSize) {
    if (resultJson == NULL || resultSize <= 0) {
        NSLog(@"‚ùå dcflight_create_session_token: Invalid parameters - resultJson=%p, resultSize=%d", resultJson, resultSize);
        return false;
    }
    
    // Zero-initialize the buffer first
    memset(resultJson, 0, resultSize);
    
    NSString* token = [NSString stringWithFormat:@"dcf_session_%lld", (long long)([[NSDate date] timeIntervalSince1970] * 1000)];
    NSLog(@"üî• dcflight_create_session_token: Creating token: %@", token);
    _saveSessionToken(token);
    
    // Verify it was saved
    NSString* savedToken = _getSessionToken();
    NSLog(@"üî• dcflight_create_session_token: Saved token (verified): %@", savedToken);
    
    const char* tokenCStr = [token UTF8String];
    if (tokenCStr == NULL) {
        NSLog(@"‚ùå dcflight_create_session_token: Failed to convert token to UTF8");
        return false;
    }
    
    size_t tokenLen = strlen(tokenCStr);
    NSLog(@"üî• dcflight_create_session_token: Token length: %zu, buffer size: %d", tokenLen, resultSize);
    
    if (tokenLen >= (size_t)resultSize) {
        NSLog(@"‚ùå dcflight_create_session_token: Token too long: %zu >= %d", tokenLen, resultSize);
        return false;
    }
    
    // Copy token to buffer
    memcpy(resultJson, tokenCStr, tokenLen);
    resultJson[tokenLen] = '\0'; // Ensure null termination
    
    NSLog(@"‚úÖ dcflight_create_session_token: Token copied to buffer: '%s' (length: %zu)", resultJson, strlen(resultJson));
    return true;
}

void dcflight_clear_session_token(void) {
    _saveSessionToken(nil);
}

void dcflight_cleanup_views(void) {
    // CRITICAL: Must execute on main thread synchronously to ensure cleanup completes
    // UI operations require main thread, and we need to wait for cleanup to finish
    SAFE_MAIN_THREAD_EXEC(^{
        [DCFlightNative.shared cleanupForHotRestart];
    });
}

